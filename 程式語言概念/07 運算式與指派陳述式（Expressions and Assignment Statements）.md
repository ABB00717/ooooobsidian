好的，各位同學，請大家坐好，準備進入程式語言設計中最核心、最實用的一章節：**運算式與指派陳述式**（Expressions and Assignment Statements）。

這不僅僅是關於「加減乘除」，而是關於程式如何**執行「行動」**、如何**改變「世界」**的基礎哲學。

---

### 教學開場白：掌握程式的「行動語法」

**1. 一句話定義核心：** 運算式 (Expressions) 與指派陳述式 (Assignment Statements) 是程式語言中**「指定計算與改變狀態」**的根本手段。

**2. 點出核心問題：** 當我們寫下一段複雜的計算邏輯時（例如 `A = B + C * D / E`），我們如何確保這段程式碼能夠**精確、無歧義地，並在預期的時間點**完成其計算，從而可靠地「改變記憶體中的狀態」？

要回答這個問題，我們必須馴服運算符的野性，並確保數據類型之間能夠和睦相處。

**3. 建立三大支柱：** 為了解決這種計算邏輯的模糊性與執行順序的可靠性，我們將建立三個核心支柱：

- **運算符的秩序 (Operator Order)：** 確立優先級（Precedence）和結合性（Associativity），決定運算式「如何被解析和計算」。
- **數據的可靠性 (Data Integrity)：** 處理運算過程中的類型轉換（Type Conversions）和強制類型轉換（Coercion），確保計算對象「是否適當」。
- **狀態的更新 (State Update)：** 探討指派陳述式（Assignment Statements）的各種形式，這是命令式語言實現「改變狀態」的**精髓**。

**4. 串連概念：** 在命令式語言中，這三個概念緊密相連：運算符的秩序建立了計算的藍圖；數據的可靠性確保了計算的合法性；而最終，指派陳述式則將運算式產生的新值**綁定**到變數上，完成程式世界的狀態遷移。

現在，讓我們根據教材的章節架構，深入解析這些支柱。

---

## 第七章 運算式與指派陳述式 深度解析

本章節的討論將圍繞以下八個核心議題展開：

### 7.1 引言 (Introduction)

運算式是程式語言中指定計算的**基本手段**。為了真正理解運算式求值的過程，程式設計師必須熟悉**運算符（operator）**和**運算元（operand）**的求值順序。

值得注意的是，在我們主要關注的**命令式語言**（Imperative Languages）中，**指派陳述式**（Assignment Statements）扮演著主導性的角色，這是命令式語言的本質體現。

### 7.2 算術運算式 (Arithmetic Expressions)

算術運算式是程式語言中最基礎的運算形式，其特性大多繼承自數學慣例。

#### 7.2.1 運算符求值順序 (Operator Evaluation Order)

運算符的**優先級** (precedence) 和**結合性** (associativity) 規則共同決定了運算式中運算符的求值順序。

> 不是所有的程式語言都遵循同樣的規則

> Overloading 以及 Mixing 現在基本上都是必要的

1. **優先級規則 (Precedence Rules):**
    - 在大多數命令式語言中，優先級遵循數學常規。
    - 最高的通常是冪運算（如果語言提供，例如 Ruby 的 `**`），其次是乘法、除法和取餘數 (`*`, `/`, `%`)，最低的是二元加法和減法。
	> 也就是通常 `()` 是最高的，所以不確定的都用 `()` 就對了 xD
    - 值得一提的是，APL 語言是一個異類，它僅有一個優先級層次，而且也是右結合。強迫城市設計師必須使用 `()`。
2. **結合性規則 (Associativity Rules):**
    - 對於優先級相同的運算符（例如 `+` 和 `-`），結合性規則決定了它們的求值順序。
    - 在 C 家族語言中，加減運算通常是**左結合**（left associative），即從左到右執行。
	> 通常也都是左結合
    - Fortran 和 Ruby 的冪運算符（`**`）則是**右結合**（right associative）。
    > `a**b**c` 就會有差
3. **括號 (Parentheses):** 程式設計師可以透過括號來覆蓋預設的優先級和結合性，以強制特定的求值順序。
#### 7.2.2 運算元求值順序 (Order of Operand Evaluation)

如果運算式中的某個運算元是**具有副作用**的函數呼叫，那麼運算元的求值順序至關重要。

- **副作用 (Side Effects):** 當一個函數（或運算元）在計算其返回值時，也改變了其參數、全域變數或進行 I/O 操作，即發生了副作用。
- **問題示例：** 在 C 語言中，如果我們執行 `a = a + fun1()`，且 `fun1()` 改變了全域變數 `a` 的值，那麼最終 `a` 的結果將取決於是先計算左邊的 `a`，還是先呼叫 `fun1()`。如果語言標準沒有規定運算元的求值順序，程式的行為就會變得不可預測且不可靠。

#### 7.2.3 條件運算式 (Conditional Expressions)

C 家族語言（包括 C++ 和 C#）提供了三元運算符 `?:`，允許將 `if-then-else` 的邏輯寫入單一指派陳述式中。 例如：`average = (count == 0) ? 0 : sum / count;`。

#### 7.2.4 Ruby 運算式

Ruby 是一種純物件導向語言，這對其運算式產生了根本影響：

- Ruby 中的所有數據值（包括文字量）都是物件。
- 所有的算術、關係和指派運算符都是作為**方法**（methods）實現的。
- 例如，運算式 $a + b$ 實際上是對物件 $a$ 呼叫名為 `+` 的方法，並將物件 $b$ 作為參數傳遞。

> functional side effects
> 1. 參數改變會（回傳）
> 2. non-local
> ```c
> a = 10
> b = a + func(a)
> ```

> functional programming lanugage 就不會有這種副作用的問題
> （幹我忘記他的啥特性了，好像就是每次給它啥都的結果一定會是固定的？而且不同函式之間狀態不會共享？我忘了哈哈幹反正就是那個讓他們成為天然避免並行衝突的特性）

#### 7.2.5 Referential Transparency
可以在任意處替換函式呼叫，並且絕對能得到相同的結果。純函式導向程式語言全都是 referential transparency。他們絕對不會有副作用。

### 7.3 運算符重載 (Overloaded Operators)

運算符重載是指單一運算符符號具有多種解釋。

- **預定義重載：** 許多語言（如 C++）允許 `+` 運算符處理不同類型（例如，整數加法和浮點數加法）。
- **使用者定義重載：** C++ 和 Ada 允許使用者為自己定義的類型（例如抽象數據類型）重載運算符。
- **問題：** 雖然重載增加了表達能力（Expressivity），但如果重載後的運算符語義與其傳統數學語義不符，則可能嚴重損害**可讀性**。例如，C 語言中 `&` 既是位元 AND 運算符，也是取址運算符，這損害了可讀性。因此實務上會避免使用（那時候大家比較叛逆，都想要看起來和別人不一樣）。

### 7.4 類型轉換 (Type Conversions)

#### 7.4.1 混合模式運算式中的強制轉換 (Coercions in Mixed-Mode Expressions)

**混合模式運算式** (Mixed-Mode Expressions) 包含多種數據類型的運算元。在這種情況下，語言通常會使用**強制類型轉換**（Coercion），將運算元隱式轉換為相容的類型後再進行運算。

- **擴寬轉換 (Widening Conversions):** 將值轉換為一個能夠容納所有可能值（不丟失精度）的類型（如 `int` 轉 `float`），通常是安全的。這是安全的，很多程式語言會隱性做此操作（比方說你在加減乘除然後兩數不同類型時）。
- **縮窄轉換 (Narrowing Conversions):** 將值轉換為一個無法容納其所有可能值的類型（如 `float` 轉 `int`），可能導致信息丟失。
- Java 僅允許**擴寬**的強制類型轉換，以提高安全性。
- Ada 沒有任何的轉換機制，會直接丟錯誤（為了安全，但其實沒什麼必要）

#### 7.4.2 顯式類型轉換 (Explicit Type Conversion)

大多數語言提供了執行顯式類型轉換的能力，通常使用 **Casting** 機制。顯式轉換可用於執行縮窄轉換，但有時會導致編譯器發出警告。

>  很像一種函式呼叫。

#### 7.4.3 Errors in Expressions
數學計算限制：division by zero
電腦計算限制：overflow
通常就丟回錯誤讓程式設計師處理。

### 7.5 關係與布林運算式 (Relational and Boolean Expressions)

#### 7.5.1 關係運算式 (Relational Expressions)

關係運算符比較兩個運算元的值，產生一個**布林值**（Boolean value）。關係運算符的優先級**總是低於**算術運算符，這使得 `a + 1 > 2 * b` 這類表達式能夠正確地先計算算術部分。

#### 7.5.2 布林運算式 (Boolean Expressions)

布林運算式由布林變數、布林常數、關係運算式和布林運算符組成。

- **優先級差異：** 在數學布林代數中，AND 和 OR 運算符應具有相同的優先級，但 C 家族語言賦予 AND 高於 OR 的優先級。
- **可讀性與可靠性：** C 家族語言允許非布林值的算術運算式作為布林運算元，這降低了錯誤檢測能力，並損害了可讀性。相比之下，其他命令式語言通常會將此類操作視為錯誤。

>  在寫 C 時不要混著寫。Ex. `1 < 2 < 3` 

### 7.6 短路求值 (Short-Circuit Evaluation)

**短路求值** (Short-Circuit Evaluation) 是指在布林運算式中，一旦第一個運算元足以確定整個運算式的結果，求值過程就會停止。

- **必要性與優勢：** 短路求值對於程式的**可靠性**至關重要。例如，在檢查數組邊界時，如 `while ((index < listlen) && (list[index] != key))`，如果 `index` 等於 `listlen`，短路求值能確保第二個關係運算式（可能導致越界錯誤）不會被計算。
- **支援：** C 家族語言（使用 `&&` 和 `||` 符號）、Ruby、Perl、ML、F# 和 Python 的邏輯運算符都支持短路求值。

> 有 `|` 和 `&` 可以不要短路求值

### 7.7 指派陳述式 (Assignment Statements)

#### 7.7.1 簡單指派 (Simple Assignments)

指派陳述式是命令式語言的中心構造，它允許使用者動態地改變變數與值的綁定。

- **運算符：** 雖然許多語言使用 `=`（例如 C 家族），但 Ada 和 ALGOL 60 則使用 `:=`，以避免與相等關係運算符混淆。
- 在某些語言中（如 Fortran 和 Ada），指派陳述式必須作為獨立的陳述式存在，且目標僅限於單個變數。

#### 7.7.2 複合指派運算符 (Compound Assignment Operators)

複合指派運算符（例如 `+=`, `*=`, `-=`）是將目標變數同時用作右側運算式的第一個運算元的簡寫方式。

#### 7.7.3 一元指派運算符 (Unary Assignment Operators)

C 家族語言、Perl 和 JavaScript 引入了兩個特殊的一元算術運算符：`++`（遞增）和 `--`（遞減）。它們可以作為前綴或後綴運算符，本質上是一種簡寫的指派陳述式。

#### 7.7.4 指派作為運算式 (Assignment as an Expression)

在 C 家族、Perl 和 JavaScript 中，指派陳述式會產生一個結果（即指派給目標變數的值）。因此，它可以作為運算式或作為其他運算式的運算元。這種設計雖然增加了表達能力，但由於引入了**副作用**，有時會損害程式的可讀性。

#### 7.7.5 多重指派 (Multiple Assignments)

Perl, Ruby 和 Lua 支持多目標、多源的指派陳述式。這對於交換變數的值非常方便，例如 Perl 中可以使用 `($first, $second) = ($second, $first);`。

#### 7.7.6 函數式語言中的指派 (Assignment in Functional Programming Languages)

在純函數式語言中，標識符僅是值的名稱，它們一旦被綁定，其值就永遠不會改變。例如，ML 使用 `val` 聲明將名稱綁定到值上，而不是指派。

### 7.8 混合模式指派 (Mixed-Mode Assignment)

混合模式指派發生在運算式結果的類型與目標變數的類型不同時。

- **設計問題：** 是否允許在指派過程中進行強制類型轉換？
- **C 家族：** 只要可能，通常允許類型轉換。
- **Java：** 僅允許**擴寬轉換**；如果需要縮窄轉換，程式設計師必須使用顯式類型轉換 (casting)。
- **ML：** 不允許混合模式指派。

至此，我們完成了對第七章核心概念的探索。請記住，對這些基本語義規則的透徹理解，是編寫可靠且高效的命令式程式碼的基石。