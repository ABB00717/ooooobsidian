# 2024
![[OS 2024 Midterm 1.png]]
## 1.
### a.
```handdrawn-ink
{
	"versionAtEmbed": "0.3.4",
	"filepath": "圖片/Ink/Drawing/2025.10.19 - 14.15pm.drawing",
	"width": 500,
	"aspectRatio": 1
}
```
### b.
running -> terminated
running -> waiting
waiting -> ready
running -> ready
### c.
running -> ready
waiting -> ready

## 2.
### a.
Program：在硬碟裡躺著的靜態指令集合
Process：作業系統資料分配及保護的最小單位。被載入到記憶體內，有獨立的記憶體空間。
Thread：在行程內動態執行的基本單位。除了一些資料以外（暫存器、程式計數器、堆疊），其餘資料執行緒間共用。
### b.
作業系統儲存當前行程的 PCB，接著載入下個行程的 PCB。

### c.
User Threads：由使用者空間管理的執行緒，由函式庫管理（像是 `pthread`），作業系統只會看到一個行程。
Kernel Threads：由內核管理的執行緒，切換時涉及系統呼叫。
Hardware Thread：實體核心在記憶體停頓切換別的任務，對外偽裝成兩個核心

## 3.
因為原本的 `compare_and_swap` 並不限制一個行程連續進入 `critical section` 的次數。

## 4.
### Mutex
要進入 `critical section` 一定得跳出 `while`，須滿足以下任意條件：
- `waiting[i] == false`：只能由別的行程在 `exit section` 達成
- `key == 0`：必須要 `lock == 0` ，也就是別的行程已經跳出 `critical section`，而因為是原子操作，所以每次只有一個行程的 `key == 0`。
因此任意時間點只有一個行程能進入 `critical section`。

### Progress
- `lock == 0`：任何想進去的行程一定可以挑一個進去（參見 Mutex）
- `lock == 1`：
  離開的行程在 `exit section` 會
  - 循環找下一個 $P_j$ 讓它 `waiting = false`，讓它可以進入 `critical section`
  - 找不到，則 `lock = 0`
  
一定能在有限時間內從想進入的行程中挑一個進入 `critical section`。
### Bounded-Waiting
在 `exit section` 會從循環找下個正在等待的行程，因此等待上限為 `n-1`。

![[OS 2024 Midterm 2.png]]
## 5.
### FCFS
P1: 1 + 11 = 12
P3: 12 + 8 = 20
P5: 20 + 4 = 24
P2: 24 + 3 = 27
P4: 27 + 2 = 29

Turnaround Time
$$
\frac{(12 - 1) + (20 - 5) + (24 - 6) + (27 - 10) + (29 - 12)}{5} = \frac{78}{5} = 15.6
$$
Average Waiting Time
$$
\frac{(1-1) + (12-5) + (20 - 6) + (24 - 10) + (27 - 12)}{5} = \frac{50}{5} = 10
$$
### SJF
P1: 1 + 11 = 12
P4: 12 + 2 = 14
P2: 14 + 3 = 17
P5: 17 + 4 = 21
P3: 21 + 8 = 29

Turnaround Time
$$
\frac{(12-1) + (14-12) + (17-10) + (21-6) + (29-5)}{5} = \frac{59}{5} = 11.8
$$
Average Waiting Time
$$
\frac{(1-1 + (12-12) + (14-10) + (17-6) + (21-5)}{5} = \frac{31}{5} = 6.2
$$
### SRTF

| Time/Process | P1  | P2  | P3  | P4  | P5  |
| ------------ | --- | --- | --- | --- | --- |
| 1            | 11  |     |     |     |     |
| 5            | 7   |     | 8   |     |     |
| 6            | 6   |     |     |     | 4   |
| 10           |     | 3   |     |     | 0   |
| 12           |     | 1   |     | 2   |     |
| 13           |     | 0   |     |     |     |
| 15           |     |     |     | 0   |     |
| 21           | 0   |     |     |     |     |
| 29           |     |     | 0   |     |     |
Turnaround Time
$$
\frac{(21-1) + (13-10) + (29-5) + (15-12) + (10-6)}{5} = \frac{54}{5} = 10.8
$$
Average Waiting Time
$P_1$ 的 6 ~ 15 這段等待時間也要算進去
### Priority Non-preemptive

| Time\Process | P1  | P2  | P3  | P4  | P5  |
| ------------ | --- | --- | --- | --- | --- |
| 1            | 11  |     |     |     |     |
| 12           | 0   | 3   | 8   | 2   | 4   |
| 20           |     |     | 0   |     |     |
| 23           |     | 0   |     |     |     |
| 25           |     |     |     | 0   |     |
| 29           |     |     |     |     | 0   |
Turnaround Time
$$
\frac{(12-1) + (23-10) + (20-5) + (25-6) + (29-12)}{5} = 15
$$
Average Waiting Time
$$
\frac{(1-1) + (20-10) + (12-5) + (23-6) + (25-12)}{5} = 9.4
$$

### Priority Preemptive
Turnaround Time
12.8
Average Waiting Time
7.2

### RR
總結：中間等待的時間也要算進去 waiting time 喔，只要是等待時間都要。
## 6.
full -> 卡著，但拿走 mutex
consumer 直接動不了。

把 producer 那邊的 mutex 和 full 換位置就好。

## 7.
### a.
Processor Affinity: 盡量讓一個執行緒在同個核心上跑。在執行緒執行過程中，一定會有資料放在該核心的L1/L2快取。如果轉移到其他核心那那些資料就要重新從記憶體抓取。
Load balancing: 要讓所有核心都有事情做。排程器會在比較忙和比較閒的核心間不斷推拉執行緒。

### b.
- soft realtime：盡量在期限內完成工作，但不保證
- hard realtime：保證、一定、必須要在期限內完成工作

### c.
- Par：多個不同核心同時進行不同的工作
- Con：一個核心不斷切換不同的工作進行

### d.
Aging: 隨著行程未被排程到的時間增加，他的優先度也會隨之提高，直到它被排程到為止

### e.
Threads Pool: 先宣告一堆執行緒，要用的時候再分配工作給它。程式設計師只需管工作內容，而不需要在意執行緒的分配與釋放。

### f.
Atomic Variables: 原子變數保證所有對該變數的寫入和讀取操作都是不可分割的，且提供記憶體順序的保證，確保操作前後的記憶體存取能被其他執行緒正確觀察到