
User-Mode如何得到Kernel-Mode的權限

（系統的架構其實不太重要，那些只是讓你了解歷史）

作業系統的描述：
- 資源分配者
- 流程控制者

---
行程的概念
行程的狀態圖。new, ready, waiting, running, terminated要會畫
行程的記憶體配置
行程的PCB，以及它裡面放的哪些東西

Ready以及Wait的PCB串起來，變成Queue

fork再複習一次。

---
Threads的概念
	會改變的動態的東西都是不一樣的（stack, PC, registers）
Concurrency以及Parallelism的區別
- Par：多個不同的行程同時進行
- Con：不斷交換不同的行程進行

請說明User Threads、Kernel Threads, hardware
- User: User Space 裡面的，user-level library
- Kernel: Kernel Space 裡面的
  User 和 Kernel 的對應有很多種方法
- Hardware: 
  在CPU裡面

顯性以及隱性Threads
- 顯性：由程式設計師指名決定要用
- 隱性：由編譯器、Library自己用的

Threads Pool：先宣告一堆執行緒，要用的時候再分配工作給它。程式設計師只需管工作內容，而不需要在意執行序的宣告和dealloc


CPU
non-preemptive：
preemptive：
（很重要喔）


每個Scheduler的特性
Quiz 2的計算題必考


PCS, SCS是啥，
process-contention scope
scope不同的threads scheduling

Homogeneous, Asymmetric mult
Multithreaded Multicore System解釋
在memory stall的時候換另一個要CPU得來用。
 Chip-multithreading，用硬體的方式來騙（hyperthreading）

Load Balancing, push/pull
Processor Affinity
- soft：盡量在同個處理器執行
- hard：指定會在哪些處理器上執行
解釋，兩者之間為何衝突。

- soft realtime：盡量在指定時間完成工作，但不保證
- hard realtime：保證在指定時間內完成工作

Priority-based Scheduling
periodically
deadline

rate montonic
在優先度固定的前提下最好的演算法。透過週期，重要、教短的優先度會很高
earliest deadline first
優先度隨時間改變的最佳演算法。檢查誰的期限比較近，越近的優先度越高。期限有改變的時候就去檢查。


---

race condition 的定義

critical section protocol

entry section
// critical
exit
// remainder

Producer & Consumer 要怎麼設計導致需要保護的 race condition。

- mutual exclusion
	- 若多個行程可以同時進出CS，找出矛盾
- progress
	- 沒有行程在CS，一個行程要進一定可以進去
	- 多個行程要進，能在有限時間內決定哪一個進去
- bounded-waiting
	- 找出一個行程進入CS的次數上限（不要永遠輪不到某個行程就好）

一定會考一段程式，要你驗證他可不可以解決 race condition

Peterson's combined Solution 一定會考，因為它能夠解決以上三點（結合前兩個解法）。

編譯器優話後順序調換結果就會出錯。

Synchronization Hardware 異常重要，Memory Barrier 怎麼解決問題的。這些必考。
記憶體屏障：前面的

Hardware Instructions
不會被中斷的程序。
Test-and-Set
Compare-and-Swap
非常重要喔。
如何用CaS實現以及證明（一定要把PPT的CaS程式碼那面搞清楚）