各位同學，歡迎來到軟體工程領域中一個看似基礎，實則充滿規模化陷阱的核心主題——版本控制與分支管理。

## 教學開場白

首先，用一句最精煉的話來定義：**版本控制系統（VCS）是工程師用來將程式碼與「時間維度」整合，並記錄所有版本修訂的基礎工具**。

這門學科存在的根本性問題是：當我們在一個預期將持續數十年、擁有數十億行程式碼（例如 Google 程式碼庫），並由數萬名工程師協作的環境中工作時，我們如何有效率且安全地管理程式碼隨著時間不斷變化的巨大複雜性，同時確保所有人都能在一個穩定且單一的基礎上工作？

為了解決這個根本問題，我們將建立三個核心支柱，它們將構成我們接下來學習的主線：

1. **版本哲學：** 理解版本控制如何作為檔案系統的延伸，明確地將「時間」納入考量。
2. **單一事實來源（Single Source of Truth, SSoT）：** 確立程式碼庫中所有變更的權威中心，避免混亂與版本衝突。
3. **規模化策略：** 制定政策以限制選擇、減少不必要的開銷，並確保程式碼庫在規模擴大時仍能維持健康，這包含了「單一版本原則」與「主幹開發」。

這三個概念彼此緊密相連：版本控制系統（版本哲學）為我們提供了追蹤時間的能力；接著，我們必須透過確立**單一事實來源**來收斂協作的中心點；最終，我們利用**單一版本原則**和**主幹開發**等策略，來確保這個單一事實來源能夠隨著時間的推移和團隊規模的擴大，始終保持高效且可維護。

---

## 深度解析：版本控制與分支管理

### 什麼是版本控制？

版本控制系統（VCS）是一種用來追蹤檔案修訂（版本）歷史的系統。如果一個軟體專案的生命週期超過一兩天，或者涉及多於一位開發者，那麼採用 VCS 幾乎是不可避免的。

從本質上講，VCS 是對標準檔案系統的延伸。傳統檔案系統提供從「文件名」到「內容」的映射，而 VCS 則提供從**（文件名, 時間, 分支）**到「內容」的映射。這種將時間納入操作的顯式考量，是區分「程式設計」與「軟體工程」的關鍵。

VCS 的重要性體現在以下幾個方面：

1. **協調性（Coordination）：** 允許多個開發者同時處理同一組檔案，並處理合併操作。
2. **可稽核性（Auditability）：** 為每一行程式碼的變更提供正式記錄，有助於滿足法規和追蹤來源。
3. **原子性（Atomicity）：** 確保對一組檔案的變更被視為單一單元提交，避免資料損壞和變更被意外覆蓋。
4. **反饋機制：** 提交到 VCS 的儀式感能促使工程師反思自己的工作，並在提交時觸發測試和靜態分析。

如果缺乏 VCS，協作會陷入混亂，如同將檔案命名為「`Presentation v5 - final - redlines - Josh's version v2`」一樣令人恐懼。

### 集中式與分散式版本控制的權衡

現代 VCS 主要分為兩大架構：

#### 1. 集中式 VCS (Centralized VCS, CVCS)

在 CVCS 中，所有操作圍繞一個單一的中央儲存庫進行。這種架構的設計理念本身就包含了「單一事實來源」的概念：最近提交到主幹（trunk/head）的版本就是當前的權威版本。

**Google 的實踐：** Google 的主要程式碼庫 (monorepo) 依賴於其內部開發的集中式 VCS **Piper**。這是基於 Google 的規模化考量：

- **規模限制：** 程式碼庫過於龐大（超過 80TB 內容與中繼資料），基於 DVCS 模型下載整個歷史記錄對開發者而言成本太高且不切實際。
- **效率：** Piper 專為大規模而設計，即使面對 50,000 名工程師和每天 60,000 到 70,000 次提交，操作依然快速且高效。

#### 2. 分散式 VCS (Distributed VCS, DVCS)

DVCS（例如 Git）不強制要求中央儲存庫，理論上任何儲存庫的副本都可以進行提交。中心性通常透過**政策**而非技術來界定，例如指定一個特定的 GitHub 儲存庫為主要來源。

雖然 DVCS 提供了卓越的離線操作和分散式協作能力，但在大規模企業環境中，仍然需要透過明確的政策來建立單一的事實來源，否則將導致難以擴展的混亂。

### 單一事實來源與單一版本原則

在任何大規模的軟體工程專案中，擁有**單一事實來源（SSoT）**至關重要。SSoT 確保開發者知道哪一個儲存庫的哪一個分支是他們應該依賴和提交的最終權威版本。

基於 SSoT 的基礎，Google 制定了一項核心的規模化政策：**單一版本原則（The One-Version Rule）**。

> **單一版本原則的核心：** 組織內的開發者在新增依賴項時，絕不能有選擇，去決定應該依賴哪個版本的既有元件。

#### 鑽石依賴與單一版本原則

如果組織允許在同一程式碼庫中存在多個版本的函式庫，就會導致著名的**鑽石依賴問題（Diamond Dependency Problem）**：

1. 當一個高層級元件 (`libuser`) 同時依賴兩個中層級函式庫 (`liba` 和 `libb`)。
2. 而這兩個函式庫又間接依賴一個底層函式庫 (`libbase`) 的**不同版本**時，就會發生衝突。

在這種情況下，如果 `libuser` 必須同時連結兩個不相容的 `libbase` 版本，建構可能會失敗，或導致難以理解的運行時錯誤。

**單一版本原則**透過強制所有專案使用同一個版本的內部函式庫（即「單一事實來源」中的那個版本）來避免這種成本高昂的衝突。如果必須更新依賴項，則需要進行大規模變更（LSC），在整個程式碼庫中一次性完成升級，消除所有舊版本的痕跡。

### 分支管理策略

關於版本控制的政策和規範，最常引起爭議的就是分支管理。

一個必須承認的前提是：**在組織內，任何未提交的工作進度，在概念上都等同於一個分支**。

#### 反模式：長生命週期開發分支

許多團隊為了隔離未完成的功能或確保主幹穩定性，會選擇使用長生命週期（long-lived）的開發分支。然而，這在規模化時是一種**反模式**：

1. **合併成本高昂：** 長時間隔離開發的分支，其合併操作是耗時、高風險的。如果合併失敗，很難隔離是哪個工程師的變更導致了問題。
2. **不必要的開銷：** 團隊會花費大量時間在「協調合併策略」上，這是一種無法擴展的開銷。
3. **安全錯覺：** 試圖透過分支策略來維持產品穩定性是錯誤的途徑。真正的穩定性來源於**徹底的測試、持續整合（CI）和嚴格的程式碼審查**。

#### 推薦策略：主幹開發（Trunk-Based Development）

高績效軟體組織採納的趨勢是**主幹開發**（或稱 head/mainline/trunk-based development）：

- **實踐方式：** 開發者直接向主幹提交微小、增量的變更。
- **功能隔離：** 尚未準備好部署的功能不應被分支隔離，而是應該提交到主幹，並使用**功能旗標（feature flags）**在運行時將其禁用或隱藏。
- **優勢：** 這樣可以減少大量合併和重新測試的開銷，從根本上消除了協調大規模分支合併的需要。

#### 發佈分支（Release Branches）

發佈分支通常是良性的。如果產品發佈頻率較低，或需要將特定版本交付給客戶（例如實體設備），建立發佈分支來代表確切的發佈程式碼是有意義的。然而，對於實現持續部署（Continuous Deployment, CD）的組織，由於可以頻繁發佈，發佈分支的需求通常也會消失。

### Google 的版本控制實務：Monorepo 與 Piper

Google 的大部分程式碼都儲存在一個單一的**單一儲存庫（monorepo）**中，供大約 50,000 名工程師使用。這使得遵守「單一版本原則」變得輕而易舉，因為儲存庫結構自然排斥版本衝突。

**核心工具與機制：**

- **Piper：** Google 內部開發的集中式 VCS，提供全球可用的服務，專注於大規模操作的高效能。
- **粒度化所有權：** Piper 支援在程式碼庫的每個檔案層級定義 `OWNERS` 檔案，明確列出允許批准提交的工程師。這種機制在不依賴物理儲存庫分離的情況下，實現了精確的權限控制。
- **主幹優先：** Google 程式碼庫中的絕大多數專案都採用主幹開發。長期開發分支極為罕見，只用於滿足極特殊的需求（例如確保長期資料格式相容性）。
- **大規模變更（LSC）：** 單一儲存庫結構極大地簡化了大規模變更的執行，因為變更無需跨越多個儲存庫進行協調。如果存在大量長生命週期分支，將使 LSC 的成本暴增。

### 結論

版本控制是軟體工程的核心工具，它使我們能夠應對「時間」維度帶來的複雜性。為了在規模上保持高效和可持續性，我們必須從政策層面進行干預：

1. **實行單一版本原則：** 消除開發者對依賴項的選擇權，這是保持組織效率和避免依賴衝突的關鍵。
2. **實行主幹開發：** 避免使用長生命週期開發分支，轉而依賴測試和 CI 來確保主幹穩定。
3. **工具輔助：** 使用能夠擴展到組織規模的 VCS，並透過工具來執行這些政策（例如，Piper 實現 SSoT，LSC 工具利用 SSoT 進行全域變更）。

理解這些原則，無論您的組織規模如何，都能幫助您構建一個更具彈性、更易於維護的軟體生態系統。